## 腾讯
### 一面题目
1、TCP相关
    1) tcp链路挂掉的问题
    如果没有收到对方的响应，则会重传数据，如果一直超时，则可以认为对方已断开连接，可以关闭连接，如果期间对方恢复上线，会收到一个重置连接的报文，关闭连接后再次发起新的连接。另一个tcp本身有心跳机制，如果对方没有及时回应，也可以判断为连接失败从而断开连接。
    2）后台是如何区分HTTP请求的HEADER和POST内容的
    HTTP报文本身是有封装请求头和请求体的，按标准解析即可，GET是把数据和host一并放进了请求头中，这也是其数据长度有限制的原因（2KB），也是和POST的区别之一，当POST请求超过1024时，由于实现的差异，可能会先发送请求后服务端验证通过返回100，客户端继续把请求体发送过去。
2、简化版的八皇后算法题
3、小程序、Vue
首先架构实现上存在差异，Vue本身作为现代框架，是可以映射到真实DOM的，事件方面也就是原生，但是小程序不一致，他需要在原生的应用上去探测用户行为再转发给js运行时作出响应再更新视图，实际上和浏览器的事件模型是一致的，但是简易很多，所以事件也没那么多。而小程序在架构上是把js运行时、ui层分开的，也就会造成一些性能损耗，在应用层面小程序可以通过jsbridge调用原生能力，两者在生命周期上也是有不同的，后者更简单，数据流方面（UI和数据），Vue双向绑定而小程序是单向的，只能通过setData主动触发更新。
4、IM多个用户登录的实现
5、小程序登录的问题
先向js sdk拿到code，在后台请求微信服务拿到用户信息（union code之类的），已方后台拿到这些信息以后在根据它拿到对应账户的信息，返回对应的登录态，实际上就是一种SSO服务。

## 头条
### 二面
实现一棵DOM树
给出如下输入
```js
var el = require('./element')

var ul = el('ul', {id: 'list'}, [
  el('li', {class: 'item'}, ['Item 1']),
  el('li', {class: 'item'}, ['Item 2']),
  el('li', {class: 'item'}, ['Item 3'])
])
document.body.appendChild(ul.render())

// 实现
function Element (tagName, props, children) {
  this.tagName = tagName
  this.props = props
  this.children = children
}

function el(tagName, props, children) {
  return new Element(tagName, props, children)
}

Element.prototype.render = function () {
  var el = document.createElement(this.tagName) // 根据tagName构建
  var props = this.props

  for (var propName in props) { // 设置节点的DOM属性
    var propValue = props[propName]
    el.setAttribute(propName, propValue)
  }

  var children = this.children || []

  children.forEach(function (child) {
    var childEl = (child instanceof Element)
      ? child.render() // 如果子节点也是虚拟DOM，递归构建DOM节点
      : document.createTextNode(child) // 如果字符串，只构建文本节点
    el.appendChild(childEl)
  })

  return el
}
```
