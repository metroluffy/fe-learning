# TCP与HTTP - 计算机网络知识

## TCP-IP四层/OSI七层模型
通过分层，使复杂的网络协议简单化，每一层都有自己的职责。
```
// TCP/IP参考模型
├── 应用层
├── 传输层
├── 网络互连层
├── 网络访问（链接）层

注：
1、在这个模型下，TLS工作在应用层


// OSI七层模型
├── 应用层
├── 表示层
├── 会话层
├── 传输层
├── 网络层
├── 数据链路层
└── 物理层
```
more：[TCP/IP参考模型](https://zh.wikipedia.org/wiki/TCP/IP%E5%8D%8F%E8%AE%AE%E6%97%8F#TCP/IP%E5%8F%82%E8%80%83%E6%A8%A1%E5%9E%8B)

## DNS
- DNS查询，简单来说，DNS工作在应用层，浏览器把域名信息交给计算机中DNS应用去解析得到目标的ip地址（当然DNS也为其他应用程序提供解析服务）。其过程一般是先查询本地的DNS缓存，如果没有再请求其上一级DNS服务器做递归查询直至根服务器，通信采用UDP，优点是所需的数据包更少 。

- 小知识点  
为什么只有13个根服务器，因为受限于DNS512字节报文的限制，一个UDP报文如果因为size > MTU（最大传输单元）是需要IP分片，会大大降低可用性（依赖于网络环境）。标准MTU值为576字节，减去UDP+ IP（8+20）还剩540

## 传输层（TCP/UDP）

### TCP/UDP差异
- TCP
  - 面向连接、字节流
  - 有状态，保证可靠交付
  - 具备拥塞控制
  - 点对点传播
  - 有序
- UDP
  - 无连接、面向数据报
  - 无状态，不保证可靠交付
  - 不具备拥塞控制
  - 广播、多播
  - 无序

### TCP三次握手与四次挥手

#### 三次握手
三次握手，浏览器和服务端各自验证一次序列号（同步连接双方的序列号和确认号并交换 TCP 窗口大小信息），
双方都能明确自己和对方的收、发能力是正常的，SYN+ACK（SYN-同步序列编号，ACK-确认讯息讯号）。
- 具体过程  
  一开始双端连接状态处于CLOSE，服务端LISTEN状态，

  1. A发送确认序列号SYN（SYN=1, seq=x）

  2. B确认请求ACK+己方的序列号SYN（SYN=1, ACK=1, seq=y, ACKnum=x+1）

  3. A发送ACK确认收到（ACK = 1，ACKnum = y+1）  

  最后，B收到ACK包以后连接进入ESTABLISHED 状态

- 异常情况

  - 客户端第一个SYN包丢了  
    触发超时重传机制（一般重试三次，每次时间都延长，大部分系统最长75s）

  - 服务端收到「SYN」并回复的「SYN,ACK」包丢了  
    双方超时重传，此时客户端情况相当于第一种，服务端处于 SYN_RCVD 状态

  - 客户端最后一次回复「SYN,ACK」的「ACK」包丢了  
    客户端进入 ESTABLISHED 状态，服务端SYN_RCVD状态，客户端可以发送数据并携带上一个ACK，服务端收到后正常建立连接

  - 客户端故意不发最后一次「SYN」包  
    属于安全攻防范畴，服务端处于半连接状态，服务端重试失败后关闭连接，但是也会消耗资源，压力增大

#### 四次挥手
四次挥手，接收到FIN报文的一方只能回复一个ACK, 它是无法马上返回对方一个FIN报文段，所以是四次挥手。
ACK+FIN，FIN表示正常关闭连接，没有数据丢失，还有一个RST表示异常的关闭连接。
- 具体过程  

  1. A请求关闭连接FIN（FIN=1，seq=x）

  2. B确认请求ACK (ACK=1，ACKnum=x+1)

  3. B请求关闭连接FIN (FIN=1，seq=y)

  4. A表示收到请求ACK (ACK=1，ACKnum=y+1)  

一般的ACK 和FIN 标记设为1。

#### 补充知识
大多数情况下，都依赖超时重传来保证 TCP 的可靠性，一部分依赖协议本身，一部分依赖操作系统，具体见对应的异常情况。
参考文章：https://network.51cto.com/art/202002/610542.htm

### TLS与SSL

TLS与SSL在传输层（位于传输层TCP与应用层之间）对网络连接进行加密。
比正常的TCP连接多一次SSL验证，浏览器与网站互相发送加密的握手消息并验证，目的是为了保证双方都获得了一致的密码，并且可以正常的加密解密数据，为后续真正数据的传输做一次测试。
非对称加密算法用于在握手过程中加密生成的密码，对称加密算法用于对真正传输的数据进行加密，而HASH算法用于验证数据的完整性。
公钥可以理解为锁，而私钥相当于钥匙

#### 具体过程
1. 客户端发送请求到服务器端，请求包含支持的SSL加密协议版本等信息
2. 服务器端返回证书和公开密钥
3. 客户端验证证书和公开密钥的有效性，如果有效，则生成共享密钥并使用公开密钥加密发送到服务器端
4. 服务器端使用私有密钥解密数据，并使用收到的共享密钥加密数据，发送到客户端
5. 客户端使用共享密钥解密数据  

以上步骤完成代表SSL加密建立，3、4、5表示浏览器与网站互相发送加密的握手消息并验证，和三次握手差不多

#### 密钥生成
考虑到性能问题，https使用非对称加密交换随机数生成秘钥，再用秘钥来对称加密数据，秘钥的生成过程跟选用的加密算法有关。
秘钥交换/生成这个过程非常复杂，大概总结一下：

1. 首先，客户端利用CA数字证书实现身份认证，利用非对称加密协商对称密钥。

2. 客户端会向服务器传输一个“pubkey”随机数，服务器收到之后，利用特定算法生成另外一个“pubkey”随机数，客户端利用这两个“pubkey”随机数生成一个 pre-master 随机数。

3. 客户端利用自己在 client hello 里面传输的随机数 random_C，以及收到的 server hello 里面的随机数 random_S，外加 pre-master 随机数，利用对称密钥生成算法生成 对称密钥enc_key：enc_key=Fuc(random_C, random_S, Pre-Master)

### HTTP

#### 版本差异
- HTTP1.0  
  存在问题：TCP 连接无法复用（短连接）、队头阻塞

- HTTP1.1：支持长连接，存在队头阻塞

- HTTP2：二进制分帧和多路复用、server push

- HTTP3  
基于UDP协议的QUIC协议实现，主要为了解決HTTP/1.1中存在的队头阻塞问题（UDP协议不面向连接无状态，轻便）。HTTP3 -> QUIC(TLS) -> UDP。

#### 队头阻塞
什么是队头阻塞？简单来说，当单个（慢）对象阻止其他/后续的对象前进时，头部一个单一的问题可以“阻塞（block）”整条“线“。队头阻塞预防和资源加载性能之间的权衡可能是值得的。  

#### 队头阻塞在HTTP1.1中
HTTP/1.1 是一个纯文本协议，它只在有效荷载（payload）的前面附加头（headers）。它不会进一步区分单个（大块）资源与其他资源。大的或慢的响应会延迟后面的其他响应，比如当加载较大的文件时（TCP分片），会阻塞后续的请求。
解决办法：
- 浏览器支持加载打开多个并行 TCP 连接（6～8个），如此请求可以分布在这些单独的连接上，并且不再有队头阻塞
- 当超过并行数量时，可以在多个域名上“分片”（sharding）资源和 使用CDN 。缺点是TCP连接带来的消耗以及TLS连接的消耗（复用token）

#### 队头阻塞在HTTP2
在资源块之前添加了帧（frames），包含流id、块大小，由此可以在一个连接上正确地复用多个资源。
甚至可以应用多种多路复用算法，自由度更高。由此基本解决了HTTP层的队头阻塞问题。缺点是多路复用是相对于HTTP协议层，TCP层无法感知，当TCP要求重传或其他异常时，会阻塞同存在于该TCP链接的多条流

#### HTTP状态码
常见的状态码如下，
- 1xx  
表示成功接收请求, 要求客户端继续提交下一次请求才能完成整个处理过程，常见的有 101（客户要求服务器转换 HTTP 协议版本，如WebSocket）、100（客户必须继续发出请求）。

- 2xx  
表示成果接收请求并已完成整个处理过程，200 成功响应，201表示请求成功被处理并创建了新资源，新资源会在应答消息体中被返回，204 No Content 成功状态响应码，表示该请求已经成功了，但是客户端客户不需要离开当前页面。

- 3xx  
需要客户进一步细化需求，以进一步完成请求。常用的有 301（永久重定向，308）、302（临时重定向，307）、304（缓存相关），实例如短网址的应用（选用302跳转，因为301会直接暴露目标地址，不易统计和抓取）。

- 4xx  
请求出错，包含语法错误或者无法正确执行逻辑，常用的有 404（无对应资源）、401（权限问题）、403 （服务器拒绝请求）、405 Method not Allowed（服务器禁止使用当前方法的请求，注意GET、HEAD不得被禁止）。

- 5xx  
服务器端程序处理出现错误，常见的有 500（服务期内内部错误）、502（错误网关）、504（网关超时）、505（HTTP 版本不受支持）。

#### 跨域
跨域，同源策略Same Origin Policy， 指协议、域名、端口三要素都相同。

1、关于同源策略的限制：
  ```
  1) 对 Cookie、LocalStorage 和 IndexDB 的读取
  2) 对 DOM 和 JS 对象的读取
  3) Ajax 请求的正常执行（出于安全原因，浏览器限制从脚本内发起的跨源HTTP请求）
  4) 不仅限于Ajax请求，例如Canvas其实也存在类似问题，无法跨域加载图片等
  5) 就浏览器实现而言，cookie区分域，而不区分端口，也就是说，同一个ip下的多个端口下的cookie是共享的。
  ```

2、简单请求/非简单请求

指不会触发 CORS 预检请求的请求，两个限定条件，超出都算非简单：
  ```
  1) HEAD、Get、POST
  2) 请求头信息不超出以下几种字段：Accept、Accept-Language、content-type、Content-Language、Last-Event-ID
  ```

3、跨域表现
```
现象：`No 'Access-Control-Allow-Origin'  header& 404`
原因：因非简单请求导致的预检请求，后台接口没有允许OPTIONS请求，导致没有办法找到对应的接口
解决方案: 后端允许options请求

现象：No 'Access-Control-Allow-Origin' header &  405
原因：允许了OPTIONS请求，但是对应的配置（如安全配置）没有正确配置
解决：后端关闭对应的安全配置
注：状态码 405 Method Not Allowed 表明服务器禁止了使用当前 HTTP 方法的请求。需要注意的是，GET与 HEAD两个方法不得被禁止，当然也不得返回状态码 405

现象：response to preflight request doesn't pass access control check & 200
原因：头部检查不匹配，导致XHR错误
解决方案：后端增加对应的头部支持

现象：head contains multiple values '*,*'，即http头部信息有两个Access-Control-Allow-Origin:*
原因：值重复设置
解决：避免重复设置该值
```

4、解决办法
```
1、设置cors头
Access-Control-Allow-Origin
Access-Control-Allow-Methods
Access-Control-Allow-Headers
Access-Control-Max-Age

2、jsonp
```

#### HTTP与TCP的关系
`HTTP->socket->tcp`

#### 补充知识
1、现代浏览器在http请求完成后是否会断开TCP连接？  
在HTTP1.0中，会断开，HTTP1.1以后实现了长连接（也就是header中的connection：keep-alive），可以维持TCP连接，从而避免了重建连接的巨大代价，同时SSL连接的开销也可以避免。  
长连接也就意味着一个TCP连接是可以发送多个http请求的，但TCP一次只能处理一个http，一般是维护一个队列来处理多个http请求，也就有了队头阻塞的问题。  
浏览器也提供一个管线化pipeline来支持多个请求发送，但是默认是关闭的，到了http2多路复用就可以支持并行http了。另外浏览器对同一HOST能够建立的TCP连接是有限制的，在chrome是6个。

2、为何http2可以实现多路复用？  
因为HTTP/1.1 不是二进制传输，而是通过文本进行传输。由于没有流的概念，在使用并行传输（多路复用）传递数据时，接收端在接收到响应后，并不能区分多个响应分别对应的请求，所以无法将多个响应的结果重新进行组装，也就实现不了多路复用。  
而http2的基石是帧和流，每个帧会标识出该帧属于哪个流，流也就是多个帧组成的数据流。就是在一个 TCP 连接中可以存在多条流。

