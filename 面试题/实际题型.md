### 实现instanceof
```javascript
function new_instance_of (l,r) {
    let c = l.__proto__
    while(true) {
        if (c === null) {
            return false
        }
        if (c === r.prototype) {
            return true
        }
        c = c.__proto__
    }
}
```
### 实现new操作符
new操作符调用构造函数返回实例，具体如下：
1. 创建一个新的对象； 
2. 将构造函数的 this 指向这个新对象； 
3. 为这个对象添加属性、方法等； 
4. 最终返回新对象。

用代码描述的话，就是：
```javascript
// 伪代码
var obj  = {}

obj.__proto__ = Foo.prototype // 绑定原型

Foo.call(obj) // 修改this指针
```
如果构造函数中显式返回一个值，且返回的是一个对象，那么 this 就指向这个返回的对象；如果返回的不是一个对象，那么 this 仍然指向实例，例如：
```js
function Foo(){

    this.user = "Lucas"

    const o = {}

    return o

    // 这里return 1的话，this指针依然指向Foo

}

const instance = new Foo()

console.log(instance.user) // undefined
```

最后来看下new的实现，
```js
function _new () {
	var fn = [].shift.call(arguments);
	//var ags = [].prototype.slice.call(arguments, 1);
    var obj = {
        __proto__ : fn.prototype,
    };
    var res = fn.apply(obj, arguments);
    return Object.prototype.toString.call(res) === "[object Object]" ? res  : obj;
}

// 也可以这样
function _new2(fn, ...args) {
    const obj = Object.create(fn);
    const res = fn.apply(obj, args)
    return Object.prototype.toString.call(res) === "[object Object]" ? res  : obj;
}
```
### call, apply, bind
都可以用来改变函数this指向。
call和apply的区别在于参数形式，后者是数组，直接返回调用结果,
bind在参数格式上和call一致，返回一个绑定了新this指针指向的函数


### 微信面试题 LazyMan

```js
// 需要满足以下功能
LazyMan('Tony');
// Hi I am Tony

LazyMan('Tony').sleep(10).eat('lunch');
// Hi I am Tony
// 等待了10秒...
// I am eating lunch

LazyMan('Tony').eat('lunch').sleep(10).eat('dinner');
// Hi I am Tony
// I am eating lunch
// 等待了10秒...
// I am eating diner

LazyMan('Tony').eat('lunch').eat('dinner').sleepFirst(5).sleep(10).eat('junk food');
// Hi I am Tony
// 等待了5秒...
// I am eating lunch
// I am eating dinner
// 等待了10秒...
// I am eating junk food


// 实现

class lazyMan {
    constructor (name) {
        this.name = name
        this.sleepTime = 0
        this.sleepFirstTime = 0
        this.taskList = []
        console.log(`Hi I am ${this.name}`);
        setTimeout(() => {
            this.next()
        }, 0)
    }
    next() {
        var fn = this.taskList.shift();
        fn && fn();
    }
    eat (f) {
        var that = this;
        var fn = (function (n) {
            return function () {
                console.log(`I am eating ${n}`)
                that.next();
            }
        })(name);
        this.taskList.push(fn);
        return this;
    }
    sleep (time) {
        var that = this;
        var fn = (function (t) {
            return function () {
                setTimeout(() => {
                    console.log(`等待了${t}秒...`)
                    that.next();
                }, t * 1000);  
            }
        })(time);
        this.taskList.push(fn);
        return this;
    }
    sleepFirst(time) {
        var that = this;
        var fn = (function (t) {
            return function () {
                setTimeout(() => {
                    console.log(`等待了${t}秒...`)
                    that.next();
                }, t * 1000);  
            }
        })(time);
        this.taskList.unshift(fn);
        return this;
    }
}
function LazyMan(name) {
    return new LazyManClass(name);
}
```


