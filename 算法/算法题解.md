###  最长单词
https://leetcode-cn.com/problems/longest-word-lcci/
未完全通过测试用例
思路：循环加哈希查找，复杂度O3
```js
/**
 * @param {string[]} words
 * @return {string}
 */
var longestWord = function(words) {
    if(words.length === 1) return words[0];
    const lm = new Map();
    let words_o = words.sort((a,b) => a.length - b.length)
    words_o.forEach(item => {
        let ar = lm.get(item.length) || []
        ar.push(item)
        lm.set(item.length, ar)
    })
    for(let i = words_o.length - 1; i >= 0; i--){
        let max = words_o[i]
        for(let j = i -1; j>= 0;j--) {
            if(max.includes(words_o[j])) {
                let sub = max.replace(words_o[j], '')
                let subl = lm.get(sub.length) || []
                if(subl.includes(sub)) {
                    return max
                }
            }
        }
    }
    return ''
};
```

### 字符串Z字形排列
题目：https://leetcode-cn.com/problems/zigzag-conversion/
题解：
我一开始从xy二维的角度去理解，先往下走再往上走，无疑增加了实现难度，以下是一个比较巧妙的解法，对应数组或者字符每次加入一个字符，也是先下后上的一个过程。
```js
/**
 * @param {string} s
 * @param {number} numRows
 * @return {string}
 */
var convert = function(s, numRows) {
    if(numRows===0)return ''
    if(numRows===1)return s
    var isDown = false
    var nowRow = 0
    var array = new Array(numRows).fill('')
    for(let i in s) {
        array[nowRow]+=s[i]
        if(nowRow===numRows-1){
            isDown = false
        } else if(nowRow===0){
            isDown = true
        }
        nowRow+=isDown?1:-1
    }
    return array.join('')
};
```

### 求丑数
我们把只包含因子 2、3 和 5 的数称作丑数（Ugly Number）。求按从小到大的顺序的第 n 个丑数
```js
/**
 * @param {number} n
 * @return {number}
 */
// 解题思路
// 每个丑数必然是由小于它的某个丑数乘以2，3或5得到的，这样我们把求得的丑数都保存下来，用之前的丑数分别乘以2，3，5，找出这三这种最小的并且大于当前最大丑数的值，即为下一个我们要求的丑数。
var nthUglyNumber = function(n) {
    let p2=0,p3=0,p5=0;
    let dp=[n];
    dp[0]=1;
    for(let i=1;i<n;i++){
        let t1 = dp[p2]*2;
        let t2 = dp[p3]*3;
        let t3 = dp[p5]*5;
        dp[i]=Math.min(t1,t2,t3);
        if(dp[i]==t1) p2++;
        if(dp[i]==t2) p3++;
        if(dp[i]==t3) p5++; 
    }
    return dp[n-1];
};
```

###  n个骰子点数之和及其概率

题目链接：https://leetcode-cn.com/problems/nge-tou-zi-de-dian-shu-lcof/
比较好的题解：https://leetcode-cn.com/problems/nge-tou-zi-de-dian-shu-lcof/solution/nge-tou-zi-de-dian-shu-dong-tai-gui-hua-ji-qi-yo-3/

这是一道标记为easy难度的动归题，要求结果返回n个骰子点数之和的概率。

关于动态规划：
可以理解为数列题，解题时可以先输出一部分结果看看规律，如下：
1、寻求子序列（建立状态转移方程）
2、缓存结果下次调用
3、从小往大计算

注：对于比较简单的场景，状态转移方程可以直接先推出一部分结果来找规律得出，比如斐波那契数列，1，1，2，3，5...fn = f(n-1) + f(n-2)。

更好的解释：https://www.zhihu.com/question/39948290/answer/883302989

解题思路：只要求出点数之和出现的次数，再除以点数组合数，即得解。
1、求状态转移方程
 第一步，确定问题解的表达式。可将f(n, s) 表示n个骰子点数的和为s的排列情况总数。 
 第二步，确定状态转移方程。n个骰子点数和为s的种类数只与n-1个骰子的和有关。因为一个骰子有六个点数，那么第n个骰子可能出现1到6的点数。所以第n个骰子点数为1的话，f(n,s)=f(n-1,s-1)，当第n个骰子点数为2的话，f(n,s)=f(n-1,s-2)，…，依次类推。在n-1个骰子的基础上，再增加一个骰子出现点数和为s的结果只有这6种情况！那么有：

f(n,s)=f(n-1,s-1)+f(n-1,s-2)+f(n-1,s-3)+f(n-1,s-4)+f(n-1,s-5)+f(n-1,s-6) ，0< n<=6n 
 f(n,s)=0,   s< n or s>6n

上面就是状态转移方程，已知初始阶段的解为： 
当n=1时, f(1,1)=f(1,2)=f(1,3)=f(1,4)=f(1,5)=f(1,6)=1。

代码实现：
```js
/* func:获取n个骰子指定点数和出现的次数
 * para:n:骰子个数;sum:指定的点数和
 * return:点数和为sum的排列数
 */
function getNSumCount(n, sum){
    if(n<1||sum<n||sum>6*n){
        return 0;
    }
    if(n==1){
        return  1;
    }
    let resCount=0;
    resCount=getNSumCount(n-1,sum-1)+getNSumCount(n-1,sum-2)+
             getNSumCount(n-1,sum-3)+getNSumCount(n-1,sum-4)+
             getNSumCount(n-1,sum-5)+getNSumCount(n-1,sum-6);
    return resCount;
}
var twoSum = function(n) {
    const total = Math.pow(6, n);
    const res = []
    for(let i = n; i <=6*n; ++i){   //n:骰子数目
        res.push(getNSumCount(n,i)/total)
        // console.log("%d: %f/n", i, ratio);  
    }
    return res
};
```
以上即可算出结果，但是在较大规模时，使用递归会重复计算,不加优化可能会导致超时。

我们来模拟计算点数 44 和 点数 66 ，这两种点数各自出现的次数。也就是计算 getCount(2, 4)getCount(2,4) 和 getCount(2, 6)getCount(2,6)。

它们的计算公式为：
```
getCount(2,4)=getCount(1,1)+getCount(1,2)+getCount(1,3)
getCount(2,6)=getCount(1,1)+getCount(1,2)+getCount(1,3)+getCount(1,4)+getCount(1,5)
```
我们发现递归统计这两种点数的出现次数时，重复计算了
```
getCount(1,1),getCount(1,2),getCount(1,3)
```

所以进行第二步，缓存结果，改造求次数的函数即可。
```js
const rem = []
function getNSumCount(n, sum){
    if(n<1||sum<n||sum>6*n){
        return 0;
    }
    if(n==1){
        return  1;
    }
    if(rem[n] && rem[n].has(sum)){
        return rem[n].get(sum)
    }
    let resCount=0;
    resCount=getNSumCount(n-1,sum-1)+getNSumCount(n-1,sum-2)+
             getNSumCount(n-1,sum-3)+getNSumCount(n-1,sum-4)+
             getNSumCount(n-1,sum-5)+getNSumCount(n-1,sum-6);
    if(!rem[n]) {
        rem[n] = new Map()
    }
    rem[n].set(sum, resCount)
    return resCount;
}
```
性能比较：
```
twoSum(10);
// before, calc-s: 920.2119140625ms
// after, calc-s: 5.602294921875ms
```


### 连续数列
题目链接：https://leetcode-cn.com/problems/contiguous-sequence-lcci/

给定一个整数数组（有正数有负数），找出总和最大的连续数列，并返回总和。

示例：
```
输入： [-2,1,-3,4,-1,2,1,-5,4]
输出： 6
解释： 连续子数组 [4,-1,2,1] 的和最大，为 6。
```
解题思路：要求是连续子序列，自然就不能先排序了，首先想到的是滑动窗口，指针往前走，由于结果要求是和，所以窗口内只用存储值，如果下一个数比窗口内的和都大，舍弃当前结果，否则将其纳了窗口

实现如下：
```js
var maxSubArray = function(nums) {
        let max=nums[0];
        let result=max;
        for(let i=1;i<nums.length;i++){
            if(max+nums[i]>nums[i]){
                max=max+nums[i];
            }else{
                max=nums[i];
            }
            result=max>result?max:result;
        }
        return result;
};
```

更优的解法是分治法，具体可以自行搜索。