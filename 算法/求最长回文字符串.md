### 解法一
输出所有的字串，长度递减排序，循环排序结果去找回文串，找到则输出。
```js
var partition = function(s) {
    // const s1 = s.split()
    let arr = []
    for(let i = 0; i < s.length; i++){
        for(let j =  i; j< s.length;j++){
            arr.push(s.slice(i,j+1))
        }
    }
    return Array.from(new Set(arr)).sort((a,b) => a.length > b.length ?  -1: 1)
};
var isPalindrome = function(s) {
    let i = 0, j = s.length - 1;
    while(i <= j) {
        if(s[i] !== s[j]){
            return false
        }
        i++;
        j--;
    }
        return true;
};
var longestPalindrome = function(s) {
    let as = partition(s)
    let i = ''
    as.some(item => {
       if(isPalindrome(item)) {
           i = item;
           return true
       }
    })
    return i
};
```
O(n^3)，在应对超长字符串时超时;

优化思路是，不用等算出所有的字串后再去遍历查找，而是在生成字串的时候就去判断回文，并把最长的存起来，最后返回。时间复杂度不变,但不至于超时。
```js
var isPalindrome = function(s) {
    let i = 0, j = s.length - 1;
    while(i <= j) {
        if(s[i] !== s[j]){
            return false
        }
        i++;
        j--;
    }
        return true;
};
var longestPalindrome = function(s) {
    if(!s) return ''
    let m = ''
    for(let i = 0; i < s.length; i++){
        for(let j =  s.length; j> i;j--){
            let s1 = s.slice(i,j+1)
            if(s1.length > m.length && isPalindrome(s1)) m = s1
        }
    }
    return m
};
```

### 解法二